#C16.txt, March 18, 2024
Help:=proc(): print(`SR(INI,L,n), IsPer1(L,t), FindPer(L) `):end:

#SR(INI,L,n): inputs a 0-1 list of length L[nops(L)]
# a list of increasing positive integers L, and outputs
#the sequence of 0-1 generated by them of length n
#outputs the list of length n generated by the recurrence
#x[t]=x[t-L[1]]+...+x[t-L[nops(L)]
SR:=proc(INI,L,n) local r,i,M,ng:
r:=nops(L):
if nops(INI)<>L[-1] then
 RETURN(FAIL):
fi:

if not (convert(INI,set)={0,1} or convert(INI,set)={1}) then
 RETURN(FAIL):
fi:

if not (type(L,list) and {seq(type(L[i],posint),i=1..nops(L))}={true} and sort(L)=L) then
   RETURN(FAIL):
fi:
if not type(n,posint) then
     RETURN(FAIL):
fi:

M:=INI:

while(nops(M))<n do
 ng:=add(M[-L[i]],i=1..r) mod 2:
 M:=[op(M),ng]:
od:
M:

end:

#IsPer(L,t): Is L periodic of period t?
IsPer:=proc(L,t) local i:
if {seq(L[i]-L[i+t],i=1..nops(L)-t)}={0} then
  true:
else
 false:
fi:
end:

FindPer:=proc(L) local t:
for t from 1 to trunc(nops(L)/2) while not IsPer(L,t) do od:
if t=trunc(nops(L)/2)+1 then
RETURN(FAIL):
else
 RETURN(t):
fi:
end:





#1 

#2
qSR := proc(q,INI,L,n):
    r:=nops(L):
    if nops(INI)<>L[-1][2] then
        RETURN(FAIL):
    fi:

    M:=INI:
    while(nops(M))<n do
        ng:=add(L[i][2]*M[-L[i][2]],i=1..r) mod q:
        M:=[op(M),ng]:
    od:
M:
end:

#3
# The first one had a period too large to detect
# The second one had a period too large to detect
# The third one had a period of 1330
# The fourth one had a period of 62
